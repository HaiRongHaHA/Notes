# 可执行代码
- 全局代码
- Eval 代码
- 函数代码

# 作用域
- 全局作用域
- 函数作用域
- 块级作用域 es6

# 执行流程
1. 创建全局执行上下文栈

2. 准备阶段
    - 创建词法环境（全局-对象式，函数-声明式）
    - 创建执行上下文（全局执行上下文全局词法环境，this为全局对象、函数执行上下文）
    - 压入执行栈

3. 编译阶段
    - 登记变量到相应词法环境
    - 登记函数到相应词法环境（函数懒解析，静态作用域，封装闭包，构建作用域链）
    - var、function 进行提升
    - let、const 暂时性死区

4. 执行阶段
    - 从词法环境找到登记过的变量赋值
    - 遇到块级作用域
        * 创建子词法环境
        * 成为当前执行上下文的词法环境
        * 执行块级代码
        * 执行完后将当前词法环境还给父词法环境
        * 块级作用域不会生成新的执行上下文，只会生成新的词法环境
    - 遇到函数执行
        * 重复以上准备阶段、编译阶段、执行阶段、弹出上下文

4. 弹出上下文
    - 函数上下文，执行完毕立即弹出执行栈
    - 全局上下文弹出，在关闭浏览器时
    - 弹出后，上下文不存在了，但是闭包还有使用的，词法环境还是存在的


# 词法环境
用处：登记变量/函数、查找变量/函数

组成：环境记录项 + 外部词法环境引用

## 环境记录项

### 声明式环境记录项 
用于定义那些将 **标识符** 与 **语言值直接绑定**的 ECMA 脚本语法元素。声明式初始环境记录项为{}

- 函数定义
- 变量定义
- Catch 语句

### 对象式环境记录项
用于定义那些将 **标识符** 与 **具体对象的属性** 绑定的 ECMA 脚本元素。

- 程序
- With 表达式

## 外部词法环境引用
- 全局词法环境的外部词法环境引用为null
- 方便查找词法环境外部词法环境，形成一个链条，方便函数编译时生成作用域链


# 变量提升
代码编译构造词法环境时，var登记到环境记录项时，初始会为其赋值undefined，后续执行的时候才会将代码中真正的值赋上
```
console.log(a) // undefined
var a = 1;
console.log(a) // 1
```

# 暂时性死区
代码编译构造词法环境时，let、const标识符声明的变量，不赋初始值，环境记录项取值方法中做了拦截，uninitialized未初始化的取值会抛错，不能在赋值前取值，不作提升。
```
console.log(a) // Uncaught SyntaxError: Identifier 'a' has already been declared
let a = 1;
console.log(a) // 1
```

# 函数提升
代码编译构造词法环境时，function登记到环境记录项时，已经初始化过函数实例，故可以在声明前调用；

函数与变量标识符相同时，函数提升优先于变量；
```
console.log(a) // ƒ b(){return 2}
a(); // 2
var a = 1;
function a(){return 2};
```

# 词法环境登记函数实例

- 函数标识符
- 函数内容字符串（v8都是懒解析的，刚开始只编译第一层，执行了才编译）
- 静态作用域（函数作用域在定义时决定的，不是执行时决定的）

## 作用域
- 本地词法环境包括this指向
- 闭包 (inner)
- 闭包 (outer)
- 全局词法环境

AO/VO都是es3的说法了，现在都是词法环境/变量环境了

## 作用域链
v8在创建函数时（无需执行时），会把整个词法环境链条上所有的对象，做一个treeshaking，将函数所需要的对象打包成一个闭包，存在[[Scopes]]上，后续查找变量时一层层往下找[[Scopes]]链就行。

[[Scopes]]
- 0: Closure (outer) {a: 1}
- 1: Closure (inner) {b: 2}
- 2: Script {innermost: ƒ}
- 3: Globa

## 闭包

广义的闭包：只要创建函数就会引用一个词法环境，就是一个闭包

狭义的闭包：函数执行上下文出栈后，它的词法环境还在被引用，无法销毁

闭包的本质：是一种组合，**函数** 和 **外部词法环境** 绑定封闭到了一起


### V8中的闭包优化
ECMA标准只描述了将闭包存下来，没有说要怎么存？

- chrome：v8做了优化，闭包只存词法环境中那些被所需要的环境记录，封装一个闭包，放到堆里
- firefox：闭包则是将整个词法环境全部存下来的



# 执行上下文
## 变量环境/词法环境

## thisBinding

