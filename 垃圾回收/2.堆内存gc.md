
### 什么是垃圾
从根节点开始访问不到的就是垃圾（不用了的）


# 其他
浏览器控制台，拍快照，查看堆信息，了解原理


# 听课笔记
为什么分新生代/老生代？

代际假说：一般来说，新的对象很快就会消亡。

标记是标记的从根rootGC开始，有引用的则标记，未被标记的则清除

边界就是清理的最后一个内存
内部是线性结构
标记清除：标记完了以后，把死了的给释放
整理：一边标记，一边往左移动，最后把后面的都释放
为什么不一次性整理？（停顿原因）并发回收就是一次性清理

新生代内存很小用全停顿没什么影响

老生代内存又大又多，全停顿不能适用，标记一次时间太长，化整为零分为好几段去标记，所以用增量标记

增量标记深度优先处理
白：还未开始处理  未处理
灰：正在处理它的儿子  处理中
黑：自己和儿子都处理过了  处理过

暂停后，恢复时找灰色的标记，继续开始标记

写屏障（黑色节点指向白色节点的时候会触发写屏障，会强行将白色节点置为灰色）
```
global.a = { name: 'a' };
global.a.b = { name: 'b1' };
//执行标记工作
global.a.b = { name: 'b2' };
//继续执行标记工作
```

1.2.5.4 Lazy Sweeping(惰性清理)
当增量标记完成后，如果内存够用，先不清理，等JS代码执行完慢慢清理（地脏了先别拖，脏完了再拖）


其实增量标记和惰性清理并没有减少暂停的总时间（干一会歇一会，总时间并未减少）

新生代主要用了并行执行，全停顿状态
老生代主要用了并行执行、增量标记、惰性清理、并发回收


变量被定时器引用了，不能被回收，定时器到期后，仍不能被回收，清除定时器以后，就可以被回收了