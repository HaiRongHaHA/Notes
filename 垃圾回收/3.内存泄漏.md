

# 排查
性能监控，js堆走势图，上上下下没啥问题（用一部分释放一部分），如果一直飙升那就是内存泄漏了

手工gc


内存堆快照大小，每执行一次都比上次大，就是内存泄漏了，
比较前后堆快照，分析新对象树和增量，只增不减，点击跳转到该行代码，定位问题

距离是对象的深度
词法环境的原因全局变量let的距离是3，var的全局变量是在window下的，距离是1

## 少用全局变量
全局执行上下文会一直存在于上下文执行栈中，不会销毁，容易内存泄露
查找变量的链条比较长，比较消耗性能
容易引起命名冲突
确定需要使用的全局就是可以局部缓存
```
var a = 'a';
function one() {
    return function two() {
        return function three() {
            let b = a; // 局部缓存，减少作用域查找时间
            for (let i = 0; i < 100000; i++) {
                console.log(b);
            }
        }
    }
}
one()()();
```

[比较js代码性能](https://jsbench.me/)


共用隐藏类: 对象结构一样，属性一致，值类型一致
隐藏类可以加速对象的访问速度，快速找到对象的内存地址
对象结构动态新增或者减少了，会重新建map对象（隐藏类），性能就差了
对象结构一开始创建好的，后续动态修改对象属性的值，map对象是不会变的
隐藏类保存了对象里的每个属性对应的内存偏移地址


保持参数结构稳定：函数参数不要一会执行是数字一会执行是字符串，这样内联缓存优化就失效了
